//
//  Copyright Â© 2017 Tungsten Labs UG. All rights reserved.
//
//  Licensed according to https://www.gnu.org/licenses/gpl-3.0.html
//

public class MulticastError: NSObject {
    public static let domain = "TUNMulticastKitErrorDomain"
    
    public static let messageSentFromCurrentDeviceErrorCode = 1
    public static let messageNotMeantForCurrentDeviceErrorCode = 2;
    public static let underlyingCryptoMessageEncryptionErrorCode = 3;
    public static let underlyingCryptoMessageDecryptionErrorCode = 4;
    public static let noSessionNoSecretMessageErrorCode = 5;
    public static let noSessionWithGivenDeviceErrorCode = 6;
    public static let emptyListOfInitKeysErrorCode = 7;
    public static let unableToDecryptPayloadErrorCode = 8;
    public static let messageDuplicatedErrorCode = 9;
    public static let generatingEncryptedItemsErrorCode = 10;
    public static let unableToDecryptMessageErrorCode = 11;
    public static let keyDerivationErrorCode = 12;
    public static let sharedSecretKeyGenerationErrorCode = 13;
    public static let initKeyFromMessageNotFoundErrorCode = 14;
}

public extension NSError {
    
    private static var userInfoReasonKey: String { return "reason" }
    private static var underlyingCryptoExceptionKey: String { return "underlyingCryptoException" }
    private static var underlayingCryptoExceptionNameKey: String { return "underlayingCryptoExceptionName" }
    
    public static func errorForInitKeyFromMessageNotFound() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.initKeyFromMessageNotFoundErrorCode, userInfo: [userInfoReasonKey: "Init key from message not found. It was already used by another user or not generated by this device"])
    }
    
    public static func errorForMessageSentFromCurrentDevice() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.messageSentFromCurrentDeviceErrorCode, userInfo: [userInfoReasonKey: "Message was sent from current device"])
    }
    
    public static func errorForMessageNotMeantForCurrentDevice() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.messageNotMeantForCurrentDeviceErrorCode, userInfo: [userInfoReasonKey: "Message is not meant for current device"]);
    }
    
    public static func errorForUnderlyingCryptoMessageDecryptionError(error: NSError) -> Error {
        let exception = NSException(name: NSExceptionName(error.domain), reason: error.localizedDescription)
        return NSError(domain: MulticastError.domain, code: MulticastError.underlyingCryptoMessageDecryptionErrorCode, userInfo: [userInfoReasonKey: "Underlying CryptoKit Exception",
                                                                                                                                   underlyingCryptoExceptionKey: exception,
                                                                                                                                   underlayingCryptoExceptionNameKey: error]);
    }
    
    public static func errorForNoSessionNoSecretMessage() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.noSessionNoSecretMessageErrorCode, userInfo: [userInfoReasonKey: "There's no session yet, we should get a InitKeySecretMessage"]);
    }
    
    public static func errorForNoSessionWithGivenDevice() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.noSessionWithGivenDeviceErrorCode, userInfo: [userInfoReasonKey: "No session with a given device"]);
    }
    
    public static func errorForEmptyListOfInitKeys() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.emptyListOfInitKeysErrorCode, userInfo: [userInfoReasonKey: "The recipient has no initKeys in his public initKeys bundle"]);
    }

    public static func errorForUnableToDecryptMessagePayload() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.unableToDecryptPayloadErrorCode, userInfo: [userInfoReasonKey: "Unable to decrypt payload"]);
    }
    
    public static func errorForUnableToDecryptMessage() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.unableToDecryptMessageErrorCode, userInfo: [userInfoReasonKey: "Unable to decrypt a Secret Message"]);
    }
    
    public static func errorForDuplicatedMessage() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.messageDuplicatedErrorCode, userInfo: [userInfoReasonKey: "message already processed"]);
    }
    
    public static func errorForSharedSecretGeneration() -> Error {
        return NSError(domain: MulticastError.domain, code: MulticastError.sharedSecretKeyGenerationErrorCode, userInfo: [userInfoReasonKey: "Unable to generate a shared secret - probably due to invalid peer's public key"]);
    }
    
    public func isErrorMessageSentFromCurrentDeviceError() -> Bool {
        return self.domain == MulticastError.domain && self.code == MulticastError.messageSentFromCurrentDeviceErrorCode
    }
    
    public func isMessageDuplicatedError() -> Bool {
        return self.domain == MulticastError.domain && self.code == MulticastError.messageDuplicatedErrorCode
    }
}

